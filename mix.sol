pragma solidity *.*.*;

contract mix {

	// Mixing Function G from BLAKE2B
	function G(uint64[16] memory v, uint a, uint b, uint c, uint d, uint64 x, uint64 y) pure internal {

		// Dereference to decrease memory reads
		uint64 va = v[a];
		uint64 vb = v[b];
		uint64 vc = v[c];
		uint64 vd = v[d];
		
		//Optimised mixing function
		assembly{
			// v[a] := (v[a] + v[b] + x) mod 2**64
			va := addmod(add(va,vb),x, 0x10000000000000000)
			//v[d] := (v[d] ^ v[a]) >>> 32
			vd := xor(div(xor(vd,va), 0x100000000), mulmod(xor(vd, va),0x100000000, 0x10000000000000000))
			//v[c] := (v[c] + v[d])     mod 2**64
			vc := addmod(vc,vd, 0x10000000000000000)
			//v[b] := (v[b] ^ v[c]) >>> 24
			vb := xor(div(xor(vb,vc), 0x1000000), mulmod(xor(vb, vc),0x10000000000, 0x10000000000000000))
			// v[a] := (v[a] + v[b] + y) mod 2**64
			va := addmod(add(va,vb),y, 0x10000000000000000)
			//v[d] := (v[d] ^ v[a]) >>> 16
			vd := xor(div(xor(vd,va), 0x10000), mulmod(xor(vd, va),0x1000000000000, 0x10000000000000000))
			//v[c] := (v[c] + v[d])     mod 2**64
			vc := addmod(vc,vd, 0x10000000000000000)
			// v[b] := (v[b] ^ v[c]) >>> 63
			vb := xor(div(xor(vb,vc), 0x8000000000000000), mulmod(xor(vb, vc),0x2, 0x10000000000000000))
		}
		
		v[a] = va;
		v[b] = vb;
		v[c] = vc;
		v[d] = vd;
	}

	constructor() public {

		uint64[16] memory v = [
			0xb8dab0e6dad09901,
			0xcf03c5c600757ab7,
			0xdfacb1f9d9c57a93,
			0xfee2361fbf786127,
			0x99d13298ec49cd87,
			0x918b11fad70c90af,
			0xf8c12d8a31e521ef,
			0x8c308be5ba069c03,
			0x9f2afdcc19f4d225,
			0x8524cd5a09dd64e1,
			0xe77681347ec6afb3,
			0xe89a921bb73bcd33,
			0xea79de676052bfad,
			0x98d60534a88e1455,
			0xe2ddb16b4735f3b5,
			0x8fad663889763fe5
		];

		uint64[16] memory m = [
			0xfa178d7aea611c31,
			0x906be21bf1df56d5,
			0xcb84ea155d209ae9,
			0xf33f2e35821fa05f,
			0xbc8873b0c6a9216f,
			0xf50bfb78e5aac2ab,
			0xf59059b1a358e425,
			0xbbf436c25f04b11b,
			0xcd8a68ce90485ff9,
			0xe37fc528939a9e07,
			0x9c34eabceaf3be8d,
			0x9c61750f270e0107,
			0xa5ce2259f17dd9e5,
			0xd8b677d238d03555,
			0xd611b10485d34eef,
			0x807ce600be072f3d		];

		// loop over inner mixing block of BLAKE2B compression function with arbitrary input
		for (uint i=0; i < 10000; ++i) {

			G( v, 0, 4, 8, 12, m[0], m[1]);
			G( v, 1, 5, 9, 13, m[2], m[3]);
			G( v, 2, 6, 10, 14, m[4], m[5]);
			G( v, 3, 7, 11, 15, m[6], m[7]);
			G( v, 0, 5, 10, 15, m[8], m[9]);
			G( v, 1, 6, 11, 12, m[10], m[11]);
			G( v, 2, 7, 8, 13, m[12], m[13]);
			G( v, 3, 4, 9, 14, m[14], m[15]);

			G( v, 0, 4, 8, 12, m[14], m[10]);
			G( v, 1, 5, 9, 13, m[4], m[8]);
			G( v, 2, 6, 10, 14, m[9], m[15]);
			G( v, 3, 7, 11, 15, m[13], m[6]);
			G( v, 0, 5, 10, 15, m[1], m[12]);
			G( v, 1, 6, 11, 12, m[0], m[2]);
			G( v, 2, 7, 8, 13, m[11], m[7]);
			G( v, 3, 4, 9, 14, m[5], m[3]);

			G( v, 0, 4, 8, 12, m[11], m[8]);
			G( v, 1, 5, 9, 13, m[12], m[0]);
			G( v, 2, 6, 10, 14, m[5], m[2]);
			G( v, 3, 7, 11, 15, m[15], m[13]);
			G( v, 0, 5, 10, 15, m[10], m[14]);
			G( v, 1, 6, 11, 12, m[3], m[6]);
			G( v, 2, 7, 8, 13, m[7], m[1]);
			G( v, 3, 4, 9, 14, m[9], m[4]);

			G( v, 0, 4, 8, 12, m[7], m[9]);
			G( v, 1, 5, 9, 13, m[3], m[1]);
			G( v, 2, 6, 10, 14, m[13], m[12]);
			G( v, 3, 7, 11, 15, m[11], m[14]);
			G( v, 0, 5, 10, 15, m[2], m[6]);
			G( v, 1, 6, 11, 12, m[5], m[10]);
			G( v, 2, 7, 8, 13, m[4], m[0]);
			G( v, 3, 4, 9, 14, m[15], m[8]);

			G( v, 0, 4, 8, 12, m[9], m[0]);
			G( v, 1, 5, 9, 13, m[5], m[7]);
			G( v, 2, 6, 10, 14, m[2], m[4]);
			G( v, 3, 7, 11, 15, m[10], m[15]);
			G( v, 0, 5, 10, 15, m[14], m[1]);
			G( v, 1, 6, 11, 12, m[11], m[12]);
			G( v, 2, 7, 8, 13, m[6], m[8]);
			G( v, 3, 4, 9, 14, m[3], m[13]);

			G( v, 0, 4, 8, 12, m[2], m[12]);
			G( v, 1, 5, 9, 13, m[6], m[10]);
			G( v, 2, 6, 10, 14, m[0], m[11]);
			G( v, 3, 7, 11, 15, m[8], m[3]);
			G( v, 0, 5, 10, 15, m[4], m[13]);
			G( v, 1, 6, 11, 12, m[7], m[5]);
			G( v, 2, 7, 8, 13, m[15], m[14]);
			G( v, 3, 4, 9, 14, m[1], m[9]);

			G( v, 0, 4, 8, 12, m[12], m[5]);
			G( v, 1, 5, 9, 13, m[1], m[15]);
			G( v, 2, 6, 10, 14, m[14], m[13]);
			G( v, 3, 7, 11, 15, m[4], m[10]);
			G( v, 0, 5, 10, 15, m[0], m[7]);
			G( v, 1, 6, 11, 12, m[6], m[3]);
			G( v, 2, 7, 8, 13, m[9], m[2]);
			G( v, 3, 4, 9, 14, m[8], m[11]);

			G( v, 0, 4, 8, 12, m[13], m[11]);
			G( v, 1, 5, 9, 13, m[7], m[14]);
			G( v, 2, 6, 10, 14, m[12], m[1]);
			G( v, 3, 7, 11, 15, m[3], m[9]);
			G( v, 0, 5, 10, 15, m[5], m[0]);
			G( v, 1, 6, 11, 12, m[15], m[4]);
			G( v, 2, 7, 8, 13, m[8], m[6]);
			G( v, 3, 4, 9, 14, m[2], m[10]);

			G( v, 0, 4, 8, 12, m[6], m[15]);
			G( v, 1, 5, 9, 13, m[14], m[9]);
			G( v, 2, 6, 10, 14, m[11], m[3]);
			G( v, 3, 7, 11, 15, m[0], m[8]);
			G( v, 0, 5, 10, 15, m[12], m[2]);
			G( v, 1, 6, 11, 12, m[13], m[7]);
			G( v, 2, 7, 8, 13, m[1], m[4]);
			G( v, 3, 4, 9, 14, m[10], m[5]);

			G( v, 0, 4, 8, 12, m[10], m[2]);
			G( v, 1, 5, 9, 13, m[8], m[4]);
			G( v, 2, 6, 10, 14, m[7], m[6]);
			G( v, 3, 7, 11, 15, m[1], m[5]);
			G( v, 0, 5, 10, 15, m[15], m[11]);
			G( v, 1, 6, 11, 12, m[9], m[14]);
			G( v, 2, 7, 8, 13, m[3], m[12]);
			G( v, 3, 4, 9, 14, m[13], m[0]);

			G( v, 0, 4, 8, 12, m[0], m[1]);
			G( v, 1, 5, 9, 13, m[2], m[3]);
			G( v, 2, 6, 10, 14, m[4], m[5]);
			G( v, 3, 7, 11, 15, m[6], m[7]);
			G( v, 0, 5, 10, 15, m[8], m[9]);
			G( v, 1, 6, 11, 12, m[10], m[11]);
			G( v, 2, 7, 8, 13, m[12], m[13]);
			G( v, 3, 4, 9, 14, m[14], m[15]);

			G( v, 0, 4, 8, 12, m[14], m[10]);
			G( v, 1, 5, 9, 13, m[4], m[8]);
			G( v, 2, 6, 10, 14, m[9], m[15]);
			G( v, 3, 7, 11, 15, m[13], m[6]);
			G( v, 0, 5, 10, 15, m[1], m[12]);
			G( v, 1, 6, 11, 12, m[0], m[2]);
			G( v, 2, 7, 8, 13, m[11], m[7]);
			G( v, 3, 4, 9, 14, m[5], m[3]);
		}
	}
}
